\documentclass{article}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{biblatex}
\usepackage{csquotes}

\addbibresource{biblio.bib}

\graphicspath{{./images/}}
\setlength{\parindent}{0pt}
\makeindex

\pagestyle{fancy}
\fancyhf{}
\lhead{Progetto finale di Reti Logiche}
\rhead{\leftmark}
\rfoot{\thepage}

\begin{document}

\begin{titlepage}
    \centering
    \vspace*{\fill}
    \Huge\textbf{Progetto finale di \\ Reti Logiche}\\
    \vspace{5mm} %5mm vertical space
    \Large Prof. Gianluca Palermo - Anno di corso 2020-21\\
    \vspace{5mm} %5mm vertical space
    \large Francesco Pastore - Codice persona: 10629332\\
    \vspace{100mm}
    \includegraphics[scale=0.7]{logo.png}
    \vspace*{\fill}
\end{titlepage}

\thispagestyle{empty}
\tableofcontents
\pagebreak
\section{Introduzione}
Il metodo di equalizzazione dell’istogramma di una immagine è un metodo pensato per ricalibrare il contrasto di una immagine quando l’intervallo dei valori di intensità sono molto vicini effettuandone una distribuzione su tutto l’intervallo di intensità, al fine di incrementare il contrasto. \\
Lo scopo del progetto è di implementare una variante semplificata di quest'algoritmo tramite un componente hardware descritto in VHDL.

\begin{figure}[h]
    \includegraphics[width=\textwidth]{equalization.png}
    \centering
    \caption{Esempio di equalizzazione dell'istogramma di un'immagine \cite{equalization}}
\end{figure}

\subsection{Specifiche di progetto}
Descrizione della memoria

\subsection{Algoritmo in breve}
Di seguito una breve descrizione dei punti principali dell'algoritmo da implementare.

\begin{enumerate}
    \item Lettura del numero di colonne
    \item Lettura del numero di righe
    \item Verifica che l'immagine non sia vuota, altrimenti non c'è nulla da fare
    \item Lettura dei pixel dell'immagine cercando il valore minimo e massimo
    \item Calcolo del delta\_value e del relativo shift\_level
    \item Lettura dei pixel dell'immagine e calcolo del relativo new\_pixel
    \item Verifica che il valore di new\_pixel\_value sia accettabile, altrimenti ridurre a 255 il valore calcolato al punto precedente
    \item Scrittura in memoria dei nuovi valori dei pixel
\end{enumerate}

\begin{figure}[h]
    \includegraphics[width=\textwidth]{formulas.png}
    \centering
    \caption{Formule dell'algoritmo di equalizzazione fornite nella specifica}
\end{figure}

\subsection{Note di implementazione}
Necessità di aspettare \par
un ciclo di clock per attendere la lettura.


\pagebreak
\addtocontents{toc}{\protect\setcounter{tocdepth}{2}}
\section{Architettura}

\subsection{Segnali utilizzati}

\pagebreak
\subsection{Descrizione degli stati}
Il componente è stato definito con una macchina a stati in particolare possiede 14 stati descritti qui di seguito.

\subsubsection{RESET}
Lo stato di RESET è lo stato iniziale della macchina ed è l'unico raggiungibile da tutti gli altri. Quando il componente riceve un segnale di i\_rst alto, ferma l'esecuzione e tutto riparte dallo stato di reset. La macchina esce da questo stato solo con il segnale i\_start alto.

\subsubsection{READ\_COLS\_REQ}
Nel primo byte della memoria è salvato il numero di colonne dell'immagine. Questo stato si occupa di effettuare la relativa richiesta di lettura. Essendo una lettura è necessario attendere che la memoria elabori la richiesta, per questo motivo lo stato successivo è MEM\_WAIT.

\subsubsection{READ\_COLS}
Dopo aver effettuato la richiesta di lettura nello stato READ\_COLS\_REQ in questo stato la macchina legge il numero colonne passatogli dalla memoria nel bus i\_data.

\subsubsection{READ\_ROWS\_REQ}
Il secondo elemento in memoria dopo il numero di colonne è il numero di righe. Anche in questo caso è necessario effettuare la richiesta di lettura, aspettare un ciclo di clock nello stato MEM\_WAIT e solo dopo leggere il valore richiesto.

\subsubsection{READ\_ROWS}
Dopo aver effettuato la richiesta di lettura in READ\_ROWS\_REQ e aspettato per l'elaborazione da parte della memoria in MEM\_WAIT in questo stato viene letto il numero di righe passato al componente tramite i\_data.

\subsubsection{READ\_PIXELS\_START}
In questo stato viene inizializzato il contatore  e i segnali di minimo e massimo prima di effettuare la prima scansione dell'immagine. Il minimo viene settato a 255 che corrisponde al più alto valore possibile, il massimo invece a zero che rappresenta rispettivamente quello più basso. Viene controllato inoltre che non sia stata data un'immagine vuota, altrimenti si passa direttamente allo stato di DONE.

\subsubsection{READ\_PIXEL\_REQ}
Dopo aver calcolato il numero di pixel contenuti nell'immagine grazie al numero di colonne e di righe, è possibile leggerli scansionandola dall'inizio alla fine. In questo stato viene quindi settato l'indirizzo per la lettura del prossimo che verrà poi letto nello stato READ\_NEXT\_PIXEL. Il contatore necessario per la lettura viene incrementato in questo stato sfruttando un segnale temporaneo d'appoggio.

\subsubsection{READ\_PIXEL}
Dopo aver effettuato la richiesta di lettura e aspettato l'elaborazione da parte della memoria, in questo stato la macchina legge il pixel passatole nell'ingresso i\_data. Viene inoltre salvato il valore del contatore, che era stato incrementato nello stato precedente sfruttando un segnale d'appoggio.

\subsubsection{MEM\_WAIT}
La memoria richiede un ciclo di clock per l'elaborazione di una richiesta di lettura. Questo stato serve quindi come attesa dopo aver settato o\_addr e o\_en.

\subsubsection{CHECK\_MIN\_MAX}
La prima scansione serve per trovare i valori minimi e massimi dei pixel dell'immagine, in modo da poter poi effettuare l'equalizzazione. In questo stato viene quindi controllato ciascun pixel dopo la prima lettura e confrontato con i valori di massimo e minimo temporanei.

\subsubsection{WRITE\_START}
Una volta effettuata la prima scansione e aver trovato quindi il massimo e il minimo, è possibile calcolare il delta\_value dato dalla differenza dei due valori. Tramite uno switch e le relative soglie, viene determinato lo shift\_level e il relativo overflow\_threshold. Prima di poter effettuare la nuova scansione in questo stato è necessario inizializzare nuovamente il contatore.

\subsubsection{EQUALIZE\_PIXEL}
Per evitare di effettuare più volte lo stesso calcolo, in questo stato viene salvata nel segnale new\_pixel\_value la differenza tra il valore di ciascun pixel e il relativo minimo dopo ogni lettura.

\subsubsection{WRITE\_NEW\_PIXEL}
È in questo stato che la macchina scrive il valore del pixel equalizzato facendo attenzione ad effettuare lo shift solo quando non c'è overflow. A questo fine viene sfruttato il valore di soglia definito nello stato WRITE\_START sulla base del delta\_value.

\subsubsection{DONE}
È lo stato finale in cui giunge la macchina al termine di un'esecuzione completa. Viene settato o\_done alto e lo stato successivo è quello di RESET, in modo che il componente rimanga pronto per un'altra possibile esecuzione.

\subsection{Diagramma degli stati}

\begin{figure}[h]
    \includegraphics[width=\textwidth]{diagram.png}
    \centering
    \caption{Diagramma della macchina a stati, in figura sono specificate le condizioni in caso di più possibili stati successivi.}
\end{figure}


\pagebreak
\section{Risultati sperimentali}
\subsection{Simulazioni}
\subsection{Report di sintesi}

\pagebreak
\section{Conclusioni}
Possibili ottimizzazioni.

\printbibliography

\end{document}